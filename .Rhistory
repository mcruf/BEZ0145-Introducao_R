preferential_samples$amostragem <- "Preferencial"
# Combine all sampling results
all_samples <- rbind(simple_random_samples, stratified_samples, systematic_samples, preferential_samples)
AAS <- subset(all_samples, amostragem == "Aleatório simples")
p1 <- ggplot(grid, aes(x = x, y = y, fill = z)) +
geom_raster() +
geom_point(data = AAS[c(10,34,22,50,44,13,1),], aes(x = x, y = y, fill = NULL), color = "black", size = 3) +
annotate("text", x=8.5, y=9, label= "D", size = 9, fontface =2) +
annotate("text", x=AAS[10,"x"], y=AAS[10,"y"]-0.5, label= "Y(s1)", size = 5, fontface =2) +
annotate("text", x=AAS[50,"x"], y=AAS[50,"y"]-0.5, label= "Y(s2)", size = 5, fontface =2) +
annotate("text", x=AAS[44,"x"], y=AAS[44,"y"]+0.5, label= "Y(s3)", size = 5, fontface =2) +
#scale_fill_viridis()+
scale_fill_gradientn(colors = tim.colors(100), name = "Abundância") +
#geom_contour(aes(z = z), color = "black", alpha = 0.5) +
labs(title = "Campo aleatório (e.g., mapa de abundância)") +
theme_minimal() +
coord_equal() + # Ensure equal aspect ratio
theme(plot.title = element_text(hjust = 0.5))
p1
p2<-ggplot(grid, aes(x = x, y = y, fill = z)) +
geom_raster(alpha = .6) +
scale_fill_gradientn(colors = tim.colors(100), name = "Abundância") +
geom_point(data = all_samples, aes(x = x, y = y, fill = NULL), color = "black", size = 2) +
theme_minimal() +
coord_equal() +
#scale_shape_manual(values = c(16, 17, 15, 3)) + # Different
facet_wrap(factor(amostragem, c("Aleatório simples", "Aleatório estratificado", "Sistemático", "Preferencial")) ~.) +
theme(legend.position = "bottom",
strip.text = element_text(size = 12, face =2))
#ggsave("~/Documents/INLA_workshop/Day_03/Figures/amostragens.jpg", p2, dpi = 300)
ggsave("~/Documents/INLA_workshop/Day_03/Figures/amostragens.jpg", p2,
width = 15,
height = 20,
unit = "cm",
dpi = 300)
# Calculate the covariance for different distances
covariance_values <- exponential_covariance(distances, sigma2, range)
set.seed(123)
# Simulate a Gaussian Random Field for fish abundance (catches in weight) using ggplot
# 1. Define the spatial domain
x <- seq(0, 10, length.out = 50)
y <- seq(0, 10, length.out = 50)
grid <- expand.grid(x = x, y = y)
# 2. Define the covariance function (e.g., exponential covariance)
sigma2 <- 5 # Variance
range <- 2  # Spatial range
nu <- 0.5    # Smoothness parameter (for Matérn, but we'll use exponential)
exponential_covariance <- function(dist, sigma2, range) {
sigma2 * exp(-dist / range)
}
# 3. Calculate the distance matrix
dist_matrix <- as.matrix(dist(grid))
# 4. Calculate the covariance matrix
covariance_matrix <- exponential_covariance(dist_matrix, sigma2, range)
# 5. Simulate the Gaussian Random Field
library(MASS)
z <- mvrnorm(n = 1, mu = rep(0, nrow(grid)), Sigma = covariance_matrix)
# 6. Reshape the simulated field into a data frame for ggplot
grid$z <- as.vector(z)
# 7. Plot using ggplot2
library(ggplot2)
p1 <- ggplot(grid, aes(x = x, y = y, fill = z)) +
geom_raster() +
annotate("text", x=8.5, y=9, label= "D", size = 9, fontface =2) +
#scale_fill_viridis()+
scale_fill_gradientn(colors = tim.colors(100), name = "Abundância") +
#geom_contour(aes(z = z), color = "black", alpha = 0.5) +
labs(title = "Campo aleatório (e.g., mapa de abundância)") +
theme_minimal() +
coord_equal() # Ensure equal aspect ratio
# Number of samples
n_samples <- 50 #
# 8.1. Simple Random Sampling
set.seed(123)
random_indices <- sample(nrow(grid), n_samples)
simple_random_samples <- grid[random_indices, c("x", "y", "z")]
simple_random_samples$amostragem <- "Aleatório simples"
# 8.2 Stratified Random Sampling (stratify by spatial grid)
grid$x_strat <- cut(grid$x, breaks = 4) # Divide x into 4 strata
grid$y_strat <- cut(grid$y, breaks = 4) # Divide y into 4 strata
grid$spatial_strat <- paste(grid$x_strat, grid$y_strat) # Combine x and y strata
stratified_samples <- do.call(rbind, lapply(split(grid, grid$spatial_strat), function(strat) {
num_samples_strat <- ceiling(n_samples / 16) # 16 strata
if (nrow(strat) > num_samples_strat) {
strat[sample(nrow(strat), num_samples_strat), c("x", "y", "z")] # Select relevant columns
} else {
strat[sample(nrow(strat), nrow(strat)), c("x", "y", "z")] # Select relevant columns
}
}))
stratified_samples$amostragem <- "Aleatório estratificado"
# 8.3 Systematic Sampling (using a grid pattern)
side_samples <- ceiling(sqrt(n_samples)) # samples per side of the grid
x_seq <- seq(min(grid$x), max(grid$x), length.out = side_samples)
y_seq <- seq(min(grid$y), max(grid$y), length.out = side_samples)
systematic_samples_grid <- expand.grid(x = x_seq, y = y_seq)
## find the closest grid points
systematic_samples <- apply(systematic_samples_grid, 1, function(point){
distances <- sqrt((grid$x - point["x"])^2 + (grid$y - point["y"])^2)
return(grid[which.min(distances), c("x", "y", "z")])
})
systematic_samples <- do.call(rbind, systematic_samples)
systematic_samples$amostragem <- "Sistemático"
# 8.4 Preferential Sampling (sampling where abundance is high)
preferential_samples <- grid[order(as.numeric(grid$z), decreasing = TRUE)[1:n_samples], c("x", "y", "z")] # Select relevant columns
preferential_samples$amostragem <- "Preferencial"
# Combine all sampling results
all_samples <- rbind(simple_random_samples, stratified_samples, systematic_samples, preferential_samples)
AAS <- subset(all_samples, amostragem == "Aleatório simples")
p1 <- ggplot(grid, aes(x = x, y = y, fill = z)) +
geom_raster() +
geom_point(data = AAS[c(10,34,22,50,44,13,1),], aes(x = x, y = y, fill = NULL), color = "black", size = 3) +
annotate("text", x=8.5, y=9, label= "D", size = 9, fontface =2) +
annotate("text", x=AAS[10,"x"], y=AAS[10,"y"]-0.5, label= "Y(s1)", size = 5, fontface =2) +
annotate("text", x=AAS[50,"x"], y=AAS[50,"y"]-0.5, label= "Y(s2)", size = 5, fontface =2) +
annotate("text", x=AAS[44,"x"], y=AAS[44,"y"]+0.5, label= "Y(s3)", size = 5, fontface =2) +
#scale_fill_viridis()+
scale_fill_gradientn(colors = tim.colors(100), name = "Abundância") +
#geom_contour(aes(z = z), color = "black", alpha = 0.5) +
labs(title = "Campo aleatório (e.g., mapa de abundância)") +
theme_minimal() +
coord_equal() + # Ensure equal aspect ratio
theme(plot.title = element_text(hjust = 0.5))
p1
p2<-ggplot(grid, aes(x = x, y = y, fill = z)) +
geom_raster(alpha = .6) +
scale_fill_gradientn(colors = tim.colors(100), name = "Abundância") +
geom_point(data = all_samples, aes(x = x, y = y, fill = NULL), color = "black", size = 2) +
theme_minimal() +
coord_equal() +
#scale_shape_manual(values = c(16, 17, 15, 3)) + # Different
facet_wrap(factor(amostragem, c("Aleatório simples", "Aleatório estratificado", "Sistemático", "Preferencial")) ~.) +
theme(legend.position = "bottom",
strip.text = element_text(size = 12, face =2))
p2
# Calculate the covariance for different distances
covariance_values <- exponential_covariance(distances, sigma2, range)
?distances
??distances
### Simple IDW interpolation to see impact of sampling
# Convert all_samples to SpatialPointsDataFrame
grid2 <- grid
coordinates(grid) <- ~x + y
# Convert 'all_samples' into a spatial object correctly
all_samples_list <- split(all_samples, all_samples$amostragem) # Split by sampling type
perform_idw <- function(samples_df, grid) {
# Ensure the data frame has spatial coordinates
coordinates(samples_df) <- ~x + y
# Create the IDW model
idw_model <- gstat::idw(formula = z ~ 1, locations = samples_df, newdata = grid, idp = 2.0)
# Return a data frame with interpolated values
return(data.frame(grid, z_idw = idw_model$var1.pred, amostragem = unique(samples_df$amostragem)))
}
# Apply IDW to each sampling method separately
idw_results <- lapply(all_samples_list, perform_idw, grid = grid) %>%
bind_rows() # Combine results into a single data frame
p3 <- ggplot(idw_results, aes(x = x, y = y, fill = z_idw)) +
geom_raster() +
scale_fill_gradientn(colors = tim.colors(100), name = "Abundância") +
facet_wrap(factor(amostragem, c("Aleatório simples", "Aleatório estratificado", "Sistemático", "Preferencial")) ~.) +
theme_minimal() +
theme(legend.position = "bottom",
strip.text = element_text(size = 12, face =2))
ggsave("~/Documents/INLA_workshop/Day_03/Figures/interpolacoes.jpg", p3,
width = 15,
height = 20,
unit = "cm",
dpi = 300)
p3
ggplot(grid, aes(x = x, y = y, fill = z)) +
geom_raster(alpha = .6) +
scale_fill_gradientn(colors = tim.colors(100), name = "Abundância") +
geom_point(data = all_samples, aes(x = x, y = y, fill = NULL), color = "black", size = 2) +
theme_minimal() +
coord_equal() +
#scale_shape_manual(values = c(16, 17, 15, 3)) + # Different
facet_wrap(factor(amostragem, c("Aleatório simples", "Aleatório estratificado", "Sistemático", "Preferencial")) ~.) +
theme(legend.position = "bottom",
strip.text = element_text(size = 12, face =2))
set.seed(123)
# Simulate a Gaussian Random Field for fish abundance (catches in weight) using ggplot
# 1. Define the spatial domain
x <- seq(0, 10, length.out = 50)
y <- seq(0, 10, length.out = 50)
grid <- expand.grid(x = x, y = y)
# 2. Define the covariance function (e.g., exponential covariance)
sigma2 <- 5 # Variance
range <- 2  # Spatial range
nu <- 0.5    # Smoothness parameter (for Matérn, but we'll use exponential)
exponential_covariance <- function(dist, sigma2, range) {
sigma2 * exp(-dist / range)
}
# 3. Calculate the distance matrix
dist_matrix <- as.matrix(dist(grid))
# 4. Calculate the covariance matrix
covariance_matrix <- exponential_covariance(dist_matrix, sigma2, range)
# 5. Simulate the Gaussian Random Field
library(MASS)
z <- mvrnorm(n = 1, mu = rep(0, nrow(grid)), Sigma = covariance_matrix)
# 6. Reshape the simulated field into a data frame for ggplot
grid$z <- as.vector(z)
n_samples <- 50 #
# 8.1. Simple Random Sampling
set.seed(123)
random_indices <- sample(nrow(grid), n_samples)
simple_random_samples <- grid[random_indices, c("x", "y", "z")]
simple_random_samples$amostragem <- "Aleatório simples"
# 8.2 Stratified Random Sampling (stratify by spatial grid)
grid$x_strat <- cut(grid$x, breaks = 4) # Divide x into 4 strata
grid$y_strat <- cut(grid$y, breaks = 4) # Divide y into 4 strata
grid$spatial_strat <- paste(grid$x_strat, grid$y_strat) # Combine x and y strata
stratified_samples <- do.call(rbind, lapply(split(grid, grid$spatial_strat), function(strat) {
num_samples_strat <- ceiling(n_samples / 16) # 16 strata
if (nrow(strat) > num_samples_strat) {
strat[sample(nrow(strat), num_samples_strat), c("x", "y", "z")] # Select relevant columns
} else {
strat[sample(nrow(strat), nrow(strat)), c("x", "y", "z")] # Select relevant columns
}
}))
stratified_samples$amostragem <- "Aleatório estratificado"
# 8.3 Systematic Sampling (using a grid pattern)
side_samples <- ceiling(sqrt(n_samples)) # samples per side of the grid
x_seq <- seq(min(grid$x), max(grid$x), length.out = side_samples)
y_seq <- seq(min(grid$y), max(grid$y), length.out = side_samples)
systematic_samples_grid <- expand.grid(x = x_seq, y = y_seq)
## find the closest grid points
systematic_samples <- apply(systematic_samples_grid, 1, function(point){
distances <- sqrt((grid$x - point["x"])^2 + (grid$y - point["y"])^2)
return(grid[which.min(distances), c("x", "y", "z")])
})
systematic_samples <- do.call(rbind, systematic_samples)
systematic_samples$amostragem <- "Sistemático"
# 8.4 Preferential Sampling (sampling where abundance is high)
preferential_samples <- grid[order(as.numeric(grid$z), decreasing = TRUE)[1:n_samples], c("x", "y", "z")] # Select relevant columns
preferential_samples$amostragem <- "Preferencial"
# Combine all sampling results
all_samples <- rbind(simple_random_samples, stratified_samples, systematic_samples, preferential_samples)
AAS <- subset(all_samples, amostragem == "Aleatório simples")
p1 <- ggplot(grid, aes(x = x, y = y, fill = z)) +
geom_raster() +
geom_point(data = AAS[c(10,34,22,50,44,13,1),], aes(x = x, y = y, fill = NULL), color = "black", size = 3) +
annotate("text", x=8.5, y=9, label= "D", size = 9, fontface =2) +
annotate("text", x=AAS[10,"x"], y=AAS[10,"y"]-0.5, label= "Y(s1)", size = 5, fontface =2) +
annotate("text", x=AAS[50,"x"], y=AAS[50,"y"]-0.5, label= "Y(s2)", size = 5, fontface =2) +
annotate("text", x=AAS[44,"x"], y=AAS[44,"y"]+0.5, label= "Y(s3)", size = 5, fontface =2) +
#scale_fill_viridis()+
scale_fill_gradientn(colors = tim.colors(100), name = "Abundância") +
#geom_contour(aes(z = z), color = "black", alpha = 0.5) +
labs(title = "Campo aleatório (e.g., mapa de abundância)") +
theme_minimal() +
coord_equal() + # Ensure equal aspect ratio
theme(plot.title = element_text(hjust = 0.5))
p1
p2<-ggplot(grid, aes(x = x, y = y, fill = z)) +
geom_raster(alpha = .6) +
scale_fill_gradientn(colors = tim.colors(100), name = "Abundância") +
geom_point(data = all_samples, aes(x = x, y = y, fill = NULL), color = "black", size = 2) +
theme_minimal() +
coord_equal() +
#scale_shape_manual(values = c(16, 17, 15, 3)) + # Different
facet_wrap(factor(amostragem, c("Aleatório simples", "Aleatório estratificado", "Sistemático", "Preferencial")) ~.) +
theme(legend.position = "bottom",
strip.text = element_text(size = 12, face =2))
p2
#ggsave("~/Documents/INLA_workshop/Day_03/Figures/amostragens.jpg", p2, dpi = 300)
ggsave("~/Documents/INLA_workshop/Day_03/Figures/amostragens.jpg", p2,
width = 15,
height = 20,
unit = "cm",
dpi = 300)
### Simple IDW interpolation to see impact of sampling
# Convert all_samples to SpatialPointsDataFrame
grid2 <- grid
coordinates(grid2) <- ~x + y
# Convert 'all_samples' into a spatial object correctly
all_samples_list <- split(all_samples, all_samples$amostragem) # Split by sampling type
perform_idw <- function(samples_df, grid2) {
# Ensure the data frame has spatial coordinates
coordinates(samples_df) <- ~x + y
# Create the IDW model
idw_model <- gstat::idw(formula = z ~ 1, locations = samples_df, newdata = grid2, idp = 2.0)
# Return a data frame with interpolated values
return(data.frame(grid, z_idw = idw_model$var1.pred, amostragem = unique(samples_df$amostragem)))
}
# Apply IDW to each sampling method separately
idw_results <- lapply(all_samples_list, perform_idw, grid = grid2) %>%
bind_rows() # Combine results into a single data frame
p3 <- ggplot(idw_results, aes(x = x, y = y, fill = z_idw)) +
geom_raster() +
scale_fill_gradientn(colors = tim.colors(100), name = "Abundância") +
facet_wrap(factor(amostragem, c("Aleatório simples", "Aleatório estratificado", "Sistemático", "Preferencial")) ~.) +
theme_minimal() +
theme(legend.position = "bottom",
strip.text = element_text(size = 12, face =2))
p3
p3 <- ggplot(idw_results, aes(x = x, y = y, fill = z_idw)) +
geom_raster() +
scale_fill_gradientn(colors = tim.colors(100), name = "Abundância") +
facet_wrap(factor(amostragem, c("Aleatório simples", "Aleatório estratificado", "Sistemático", "Preferencial")) ~.) +
theme_minimal() +
coord_equal() +
#scale_shape_manual(values = c(16, 17, 15, 3)) + # Different
facet_wrap(factor(amostragem, c("Aleatório simples", "Aleatório estratificado", "Sistemático", "Preferencial")) ~.) +
theme(legend.position = "bottom",
strip.text = element_text(size = 12, face =2))
p3
ggsave("~/Documents/INLA_workshop/Day_03/Figures/interpolacoes.jpg", p3,
width = 15,
height = 20,
unit = "cm",
dpi = 300)
test <- read_sf("~/Downloads/GMW_v3_2020/gmw_v3_2020_vec.shp")
test <- sf::read_sf("~/Downloads/GMW_v3_2020/gmw_v3_2020_vec.shp")
head(test)
test
library(readr)
Data_RV <- read_delim("Library/CloudStorage/OneDrive-Personal/Arbeit/Collaborations/Raiane_Vital/Dados/Data_RV.txt",
delim = "\t", escape_double = FALSE,
trim_ws = TRUE)
View(Data_RV)
head(Data_RV)
head(as.data.frame(Data_RV))
length(unique(Data_RV$Species))
df <- read_delim("Library/CloudStorage/OneDrive-Personal/Arbeit/Collaborations/Raiane_Vital/Dados/Variable_RV.txt",
delim = "\t", escape_double = FALSE,
trim_ws = TRUE)
head(df)
head(as.data.frame(Data_RV))
head(df)
head(df)
View(df)
View(RD)
View(RD)
View(Data_RV)
Data_RV %>% filter(Point == "ARE_07")
library(plyr)
Data_RV %>% filter(Point == "ARE_07")
library(dplyr)
Data_RV %>% filter(Point == "ARE_07")
table(Data_RV$Year)
test<-Data_RV %>% filter(Point == "ARE_07")
table(test$Month)
table(test$Data)
library(xaringan)
inf_mr()
inf_mr()
inf_mr()
inf_mr()
inf_mr()
inf_mr()
inf_mr()
inf_mr()
inf_mr()
inf_mr()
inf_mr()
inf_mr()
inf_mr()
inf_mr()
inf_mr()
inf_mr()
inf_mr()
inf_mr()
inf_mr()
inf_mr()
inf_mr()
inf_mr()
inf_mr()
inf_mr()
inf_mr()
if(as.integer(parts[2]) == 6){ #Someitmes time appears as 1,6 or 19,6. The decimal '6' implies in 30 min, thus 1:30, 19:30
minute <- 30
} else{
minute <- as.integer(parts[2]) * (ifelse(nchar(parts[2]) == 1, 10, 1))
}
#~~~~~~~~~~~~~~~~~~~~~~~~
# Carregando os pacotes
#~~~~~~~~~~~~~~~~~~~~~~~~
#install.packages("dplyr")
library(dplyr)
setwd("~/OneDrive/Arbeit/Lectures_and_Talks/UFRN/Lectures/BEZ0145-Introducao_R/")
dados <- read.csv("palmerpenguins.csv")
head(dados)
dados %>% select(sex, health_metrics)
dados %>% select(sex, health_metrics) $>$ filter(sex == 'female', health_metrics == "overweight")
dados %>% select(sex, health_metrics) %>% filter(sex == 'female', health_metrics == "overweight")
test <- dados %>% select(sex, health_metrics) %>% filter(sex == 'female', health_metrics == "overweight")
dim(test)
test <- dados %>% select(sex, health_metrics, body_mass_g) %>% filter(sex == 'female', health_metrics == "overweight")
arrange(test, body_mass_g)
arrange(test, desc(body_mass_g))
head(arrange(test, desc(body_mass_g)))
head(dados)
rm(list=ls())
dados <- read.csv("palmerpenguins.csv")
## Primeiras 6 linhas
head(dados)
### Visualizador dos dados tipo excel ###
View(dados)
colnames(dados)
dados[ , "island"]
colnames(dados)
dados[, colnames(dados)[5]]
COLUNAS <- colnames(dados)
COLUNAS
obj <- colnames(dados)[5]
obj
summary(dados$body_mass_g)
media <- mean(dados$body_mass_g)
str(dados)
## Colunas sequenciais
dados_s <- dados %>%
select(species:diet)
head(dados)
KEEP <- setidff(COLNAMES, EXCLUDE)
KEEP <- setdiff(COLNAMES, EXCLUDE)
COLNAMES <- colnames(dados)
EXCLUDE <- c("bill_length_mm", "bill_depth_mm")
KEEP <- setdiff(COLNAMES, EXCLUDE)
COLNAMES <- colnames(dados)
COLNAMES
EXCLUDE <- c("bill_length_mm", "bill_depth_mm")
EXCLUDE
KEEP <- setdiff(COLNAMES, EXCLUDE)
KEEP
head(dados$body_mass_g)
dados_o <- dados %>%
arrange(body_mass_g) #
head(dados$body_mass_g)
head(dados_o$body_mass_g)
## Ordenando por uma coluna específica
dados_o <- dados %>%
#arrange(body_mass_g) #Em ordem crescente
arrange(desc(body_mass_g)) #Em ordem decrescente
head(dados_o)
## Criando uma nova coluna com base em coluna existente
dados_m <- dados %>%
mutate(body_mass_kg = body_mass_g / 1000)
cbind(dados_m$body_mass_g, dados_m$body_mass_kg)
table(dados$life)
table(dados$life_stage)
dados_m <- dlife_stagedados_m <- dados %>%
mutate(life_stage2 = ifelse(life_stage == 'adult', 'adult', 'sub-adult'))
table(dados_m$life_stage2)
table(dados_m$life_stage)
head(dados)
table(dados$diet)
?ifelse
if{dadosdados$life_stage  == 'adult', "adulto"}
## Trocando o tipo de variável
str(dados)
class(dados$species)
dados$species <- as.factor(dados$species)
class(dados$species)
levels(dados$species)
nlevels(dados$species)
### alternativa
dados <- dados %>%
mutate(across(where(is.character), as.factor))
str(dados)
levels(dados_m$diet)
## Modificando os níveis de uma variável fator
dados_m <- dados %>%
mutate(sexo = ifelse(sex == 'female', "femea", "macho"),
dieta = ifelse(diet == "fish", "peixe",
ifelse(diet == "krill", "krill",
ifelse(diet == "parental", "parental", "lula"))))
levels(dados_m$diet)
### Renomando todos os níveis
levels(dados_m$diet) <- c("peixe", "krill", "parental", "lula") #Função base
levels(dados_m$diet)
## Trocando para português
dados_r <- dados %>%
rename(especie = species,
ilha = island,
comp_bico_mm = bill_length_mm,
prof_bico_mm = bill_depth_mm,
comp_nadadeira_mm = flipper_length_mm,
massa_corporal_g = body_mass_g,
sexo = sex,
dieta = diet,
estagio = life_stage,
estado_peso = health_metrics,
ano = year)
head(dados_r)
## Calculando o peso médio por espécie de pinguim
dados %>%
group_by(species) %>%
summarise(Peso_medio = mean(body_mass_g, na.rm=T))
## Quantos pinguins há em cada categoria de peso?
dados %>%
group_by(health_metrics) %>%
#group_by(health_metrics, sex) %>%
count()
## Quantos pinguins há em cada categoria de peso?
dados %>%
#group_by(health_metrics) %>%
group_by(health_metrics, species) %>%
count()
## Quantos pinguins há em cada categoria de peso?
dados %>%
#group_by(health_metrics) %>%
group_by(health_metrics, sex) %>%
count()
## Quantos pinguins há em cada categoria de peso?
dados %>%
group_by(health_metrics) %>%
#group_by(health_metrics, sex) %>%
count()
### Proporção por categoria
dados %>%
group_by(health_metrics) %>%
summarise(Contagem = n()) %>%
mutate(Proporcao = Contagem/sum(Contagem))
